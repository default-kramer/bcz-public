[gd_scene load_steps=23 format=2]

[ext_resource path="res://Controls/GridViewerControl.cs" type="Script" id=1]
[ext_resource path="res://Sprites/joined-d.bmp" type="Texture" id=2]
[ext_resource path="res://Sprites/enemy.bmp" type="Texture" id=3]
[ext_resource path="res://Sprites/joined-r.bmp" type="Texture" id=4]
[ext_resource path="res://background.jpg" type="Texture" id=5]
[ext_resource path="res://Sprites/single.bmp" type="Texture" id=6]
[ext_resource path="res://Sprites/joined-l.bmp" type="Texture" id=7]
[ext_resource path="res://Sprites/joined-u.bmp" type="Texture" id=8]

[sub_resource type="Shader" id=11]
code = "shader_type canvas_item;

// TODO the problem is that UV.y extends off the screen.
// We should probably just build images that have the correct aspect
// ratio(s) for the known grid sizes.
// But for now, pass in `maxY` which is the maximum value of UV.y
// that is actually visible.
uniform float maxY = 0.4;

// 0.0 indicates no corruption, 1.0 indicates max corruption
uniform float corruptionProgress = 0.33;

// The following inputs tell us which columns and rows to light up.
uniform int numColumns = 8;
uniform int columnActivation = 18; // bit N lights up column N
uniform int numRows = 20;
uniform int rowActivation = 4; // bit N lights up row N
uniform float destructionIntensity = 0.0;


const vec3 corruptColor = vec3(0.337, 0.161, 0.098);
const vec3 darkGreen = vec3(0.1, 0.35, 0.05);
const vec3 greenAdder = vec3(0.4, 0.6, 0.4);

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

float corruptionCrawl(vec2 uv) {
    vec2 randseed = uv;
    float cycle = mod(TIME, 100.0) / 99.0;
    randseed = mod(randseed + vec2(cycle, cycle), vec2(1.0, 1.0));
    vec2 rand2 = random(ceil(randseed * 95.0));
    float rand = step(-0.6, rand2.x);
    return rand;
}

float getHilite(float xy, int lineCount, int lineActivation) {
    float intensity = destructionIntensity;
    //intensity = abs(sin(TIME * 2.8));

    float lineCountF = float(lineCount);
    int lineIndex = int(min(0.99, xy) * lineCountF);
    float widthPerLine = 1.0 / lineCountF;
    float middleOfLine = float(lineIndex) * widthPerLine + widthPerLine * 0.5;
    float stepStart = widthPerLine - (widthPerLine * 2.0 / 3.0) * intensity;
    float hilite = smoothstep(stepStart, widthPerLine, widthPerLine - abs(xy - middleOfLine));
    int mask = 1 << lineIndex;
    hilite = min(hilite, float(mask & lineActivation));
    return hilite;
}

void fragment() {
    vec4 tex = texture(TEXTURE, UV);
    vec2 uv = vec2(UV.x, min(1.0, UV.y / maxY)); // scale UV.y to what is actually visible
    vec4 color = tex;

    // Apply hilite
    color.rgb = color.rgb * darkGreen;
    float hilite = getHilite(uv.x, numColumns, columnActivation);
    hilite = max(hilite, getHilite(uv.y, numRows, rowActivation));
    const float glow = 0.65; // try 0.0 and 1.0 to see
    color.rgb += greenAdder * hilite * max(glow, tex.r);

    // Apply corruption
    float corruption = smoothstep(1.0 - corruptionProgress, 1.05 - corruptionProgress, uv.y);
    corruption = max(0.0, corruption - hilite);
    float rand = corruptionCrawl(UV);
    color.rgb = mix(color.rgb, tex.rgb * corruptColor, corruption * rand);

    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )
shader_param/maxY = 0.4
shader_param/corruptionProgress = 0.33
shader_param/numColumns = 8
shader_param/columnActivation = 18
shader_param/numRows = 20
shader_param/rowActivation = 4
shader_param/destructionIntensity = 0.0

[sub_resource type="Shader" id=7]
code = "shader_type canvas_item;

uniform vec3 my_color;
uniform float my_alpha;
uniform float destructionProgress;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

void fragment() {
    vec4 color = texture(TEXTURE, UV);
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);
    color = applyFizzle(color, UV);
    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 7 )
shader_param/my_color = null
shader_param/my_alpha = null
shader_param/destructionProgress = null

[sub_resource type="Shader" id=9]
code = "shader_type canvas_item;

uniform vec3 my_color;
uniform float my_alpha;
uniform float destructionProgress;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

void fragment() {
    vec4 color = texture(TEXTURE, UV);
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);
    color = applyFizzle(color, UV);
    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=10]
shader = SubResource( 9 )
shader_param/my_color = null
shader_param/my_alpha = null
shader_param/destructionProgress = null

[sub_resource type="Shader" id=5]
code = "shader_type canvas_item;

uniform vec3 my_color;
uniform float my_alpha;
uniform float destructionProgress;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

void fragment() {
    vec4 color = texture(TEXTURE, UV);
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);
    color = applyFizzle(color, UV);
    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 5 )
shader_param/my_color = null
shader_param/my_alpha = null
shader_param/destructionProgress = null

[sub_resource type="Shader" id=4]
code = "shader_type canvas_item;

uniform vec3 my_color;
uniform float my_alpha;
uniform float destructionProgress;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

void fragment() {
    vec4 color = texture(TEXTURE, UV);
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);
    color = applyFizzle(color, UV);
    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=3]
shader = SubResource( 4 )
shader_param/my_color = null
shader_param/my_alpha = null
shader_param/destructionProgress = null

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform vec3 my_color;
uniform float my_alpha;
uniform float destructionProgress;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

void fragment() {
    vec4 color = texture(TEXTURE, UV);
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);
    color = applyFizzle(color, UV);
    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/my_color = null
shader_param/my_alpha = null
shader_param/destructionProgress = null

[sub_resource type="Shader" id=13]
code = "shader_type canvas_item;

uniform vec3 my_color = vec3(1.0, .102, 0.47);
uniform float my_alpha = 1.0;
uniform float is_corrupt = 1.0; // boolean, 0.0 or 1.0
uniform float destructionProgress = 0.0; // 0.0 means not destroyed, 1.0 means fully destroyed
const vec3 corruptColor = vec3(0.337, 0.161, 0.098);

const float r1 = 0.21;
const float r2 = 0.25;

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

vec4 applyFizzle(vec4 color, vec2 uv) {
    float fizzle = destructionProgress;
    //fizzle = max(0.0, sin(TIME * 2.2));
    vec2 rand2 = random(ceil(uv * 30.0)) + 1.0;
    rand2 *= 0.5;
    if (rand2.x < fizzle) {
        color.a = 0.0;
    } else {
        vec3 headroom = vec3(1.0, 1.0, 1.0) - color.rgb;
        headroom = min(vec3(0.6, 0.6, 0.6), headroom);
        color.rgb += headroom * fizzle * fizzle;
    }
    return color;
}

float getGlow(float glow, float width, vec2 uv, float y, vec2 screenUV) {
    float y2 = mod(uv.y + TIME / 6.0, 1.0);
    return max(glow, 1.0 - smoothstep(0.0, width, abs(y2 - y)));
}

void fragment() {
    vec4 tex = texture(TEXTURE, UV);
    vec4 color = tex;
    color.rgb = my_color * color.rgb;
    color.a = min(color.a, my_alpha);

    if (1.0 < 0.0 && abs(0.5 - UV.x) < 0.3 && abs(0.5 - UV.y) < 0.3 && tex.a < 0.3) {
        float dist = distance(UV, vec2(0.5, 0.5));
        float limit = 0.2 + 0.7 * abs(sin(TIME));
        float glow = 0.0;
        glow = getGlow(glow, 0.08, UV, 0.2, SCREEN_UV);
        glow = getGlow(glow, 0.014, UV, 0.31, SCREEN_UV);
        glow = getGlow(glow, 0.08, UV, 0.48, SCREEN_UV);
        glow = getGlow(glow, 0.014, UV, 0.68, SCREEN_UV);
        glow = getGlow(glow, 0.06, UV, 0.8, SCREEN_UV);
        glow = getGlow(glow, 0.09, UV, 0.88, SCREEN_UV);
        glow = getGlow(glow, 0.04, UV, 0.96, SCREEN_UV);

        vec4 corruption = vec4(corruptColor, 1.0);
        corruption = mix(corruption, vec4(corruptColor, 1.0) * (1.0 + glow * 0.6), glow);
        color = corruption;
    }

    if (1.0 < 0.0) {
        float glow = smoothstep(0.15, 0.75, abs(sin(TIME * 2.8))) * 0.3 + 0.7;
        vec4 corruption = vec4(corruptColor, 1.0);
        corruption = mix(corruption, vec4(corruptColor, 1.0) * (1.3 + glow * 0.3), glow);

        float blah = max(abs(0.5 - UV.x), abs(0.5 - UV.y));
        blah = max(blah, distance(vec2(0.5, 0.5), UV) * 0.84);
        blah = 1.0 - smoothstep(0.2, 0.24, blah);
        color = mix(color, corruption, blah * is_corrupt);
    }

    if (1.0 < 0.0) {
        vec2 rand2 = random(ceil(UV * 90.0) * TIME / 400000000.0) + 1.0;
        rand2 *= 0.5;
        if (is_corrupt > 0.5 && rand2.x < 0.8 && rand2.y < 0.8) {
            float blah = max(abs(0.5 - UV.x), abs(0.5 - UV.y));
            blah = max(blah, distance(vec2(0.5, 0.5), UV) * 0.84);
            blah = 1.0 - smoothstep(0.2, 0.24, blah);

            color = mix(color, vec4(corruptColor * 1.6, 1.0), blah);
        }
    }

    if (1.0 < 0.0) {
        float blah = max(abs(0.5 - UV.x), abs(0.5 - UV.y));
        blah = max(blah, distance(vec2(0.5, 0.5), UV) * 0.84);
        float glow = smoothstep(0.1, 0.24, blah) * abs(sin(TIME * 2.0));
        blah = 1.0 - smoothstep(0.2, 0.24, blah);
        vec3 corruption = corruptColor;
        vec3 headroom = my_color - corruption;
        corruption += headroom * glow * 1.0;
        color = mix(color, vec4(corruption, 1.0), blah * max(1.0, is_corrupt)); // make them all corrupt
    }

    if (1.0 > 0.0) {
        // Only mix onto black pixels.
        // Remember that tex.r == tex.g == tex.b
        if (tex.r < 0.1 && tex.a > 0.5) {
            vec2 rand2 = random(ceil(UV * 20.0) + TIME / 200000.0) + 1.0;
            float mixer = step(1.2, rand2.y);
            vec4 toMix = vec4(0.0, 0.0, 0.0, 0.0);
            toMix = vec4(my_color * 0.6, 1.0); // TODO we could allow the bitmap to control this
            color = mix(toMix, vec4(corruptColor, color.a), mixer);
        }
    }

    color = applyFizzle(color, UV);

    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=14]
shader = SubResource( 13 )
shader_param/my_color = Vector3( 1, 0.102, 0.47 )
shader_param/my_alpha = 1.0
shader_param/is_corrupt = 1.0
shader_param/destructionProgress = 0.0

[node name="Control" type="Control"]
margin_right = 40.0
margin_bottom = 40.0
script = ExtResource( 1 )

[node name="Background" type="TextureRect" parent="."]
show_behind_parent = true
material = SubResource( 12 )
margin_right = 320.0
margin_bottom = 1280.0
texture = ExtResource( 5 )

[node name="JoinedDown" type="Sprite" parent="."]
visible = false
material = SubResource( 8 )
texture = ExtResource( 2 )

[node name="JoinedLeft" type="Sprite" parent="."]
visible = false
material = SubResource( 10 )
texture = ExtResource( 7 )

[node name="JoinedRight" type="Sprite" parent="."]
visible = false
material = SubResource( 6 )
texture = ExtResource( 4 )

[node name="JoinedUp" type="Sprite" parent="."]
visible = false
material = SubResource( 3 )
texture = ExtResource( 8 )

[node name="Single" type="Sprite" parent="."]
visible = false
material = SubResource( 2 )
texture = ExtResource( 6 )

[node name="Enemy" type="Sprite" parent="."]
visible = false
material = SubResource( 14 )
texture = ExtResource( 3 )
