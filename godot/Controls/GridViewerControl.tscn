[gd_scene load_steps=5 format=2]

[ext_resource path="res://Controls/GridViewerControl.cs" type="Script" id=1]
[ext_resource path="res://background.jpg" type="Texture" id=5]

[sub_resource type="Shader" id=11]
code = "shader_type canvas_item;

// TODO the problem is that UV.y extends off the screen.
// We should probably just build images that have the correct aspect
// ratio(s) for the known grid sizes.
// But for now, pass in `maxY` which is the maximum value of UV.y
// that is actually visible.
uniform float maxY = 0.4;

// 0.0 indicates no corruption, 1.0 indicates max corruption
uniform float corruptionProgress = 0.33;

// The following inputs tell us which columns and rows to light up.
uniform int numColumns = 8;
uniform int columnActivation = 18; // bit N lights up column N
uniform int numRows = 20;
uniform int rowActivation = 4; // bit N lights up row N
uniform float destructionIntensity = 0.0;


const vec3 corruptColor = vec3(0.337, 0.161, 0.098);
const vec3 darkGreen = vec3(0.1, 0.35, 0.05);
const vec3 greenAdder = vec3(0.4, 0.6, 0.4);

// Used by the noise functin to generate a pseudo random value between 0.0 and 1.0
vec2 random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}

float corruptionCrawl(vec2 uv) {
    vec2 randseed = uv;
    float cycle = mod(TIME, 100.0) / 99.0;
    randseed = mod(randseed + vec2(cycle, cycle), vec2(1.0, 1.0));
    vec2 rand2 = random(ceil(randseed * 95.0));
    float rand = step(-0.6, rand2.x);
    return rand;
}

float getHilite(float xy, int lineCount, int lineActivation) {
    float intensity = destructionIntensity;
    //intensity = abs(sin(TIME * 2.8));

    float lineCountF = float(lineCount);
    int lineIndex = int(min(0.99, xy) * lineCountF);
    float widthPerLine = 1.0 / lineCountF;
    float middleOfLine = float(lineIndex) * widthPerLine + widthPerLine * 0.5;
    float stepStart = widthPerLine - (widthPerLine * 2.0 / 3.0) * intensity;
    float hilite = smoothstep(stepStart, widthPerLine, widthPerLine - abs(xy - middleOfLine));
    int mask = 1 << lineIndex;
    hilite = min(hilite, float(mask & lineActivation));
    return hilite;
}

void fragment() {
    vec4 tex = texture(TEXTURE, UV);
    vec2 uv = vec2(UV.x, min(1.0, UV.y / maxY)); // scale UV.y to what is actually visible
    vec4 color = tex;

    // Apply hilite
    color.rgb = color.rgb * darkGreen;
    float hilite = getHilite(uv.x, numColumns, columnActivation);
    hilite = max(hilite, getHilite(uv.y, numRows, rowActivation));
    const float glow = 0.65; // try 0.0 and 1.0 to see
    color.rgb += greenAdder * hilite * max(glow, tex.r);

    // Apply corruption
    float corruption = smoothstep(1.0 - corruptionProgress, 1.05 - corruptionProgress, uv.y);
    corruption = max(0.0, corruption - hilite);
    float rand = corruptionCrawl(UV);
    color.rgb = mix(color.rgb, tex.rgb * corruptColor, corruption * rand);

    COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )
shader_param/maxY = 0.4
shader_param/corruptionProgress = 0.33
shader_param/numColumns = 8
shader_param/columnActivation = 18
shader_param/numRows = 20
shader_param/rowActivation = 4
shader_param/destructionIntensity = 0.0

[node name="Control" type="Control"]
margin_right = 40.0
margin_bottom = 40.0
script = ExtResource( 1 )

[node name="Background" type="TextureRect" parent="."]
show_behind_parent = true
material = SubResource( 12 )
margin_right = 320.0
margin_bottom = 1280.0
texture = ExtResource( 5 )
